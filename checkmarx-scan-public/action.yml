name: 'Checkmarx Scan for Public Repos (Fork-Friendly)'
description: 'Scans public repos without checking out code - safe for fork PRs with pull_request_target'
author: 'Midnight'
branding:
  icon: 'shield'
  color: 'blue'

inputs:
  project-name:
    description: 'Checkmarx project name'
    required: true
    default: ${{ github.repository }}
  cx-client-id:
    description: 'Checkmarx OAuth2 client ID'
    required: true
  cx-client-secret:
    description: 'Checkmarx OAuth2 client secret'
    required: true
  cx-tenant:
    description: 'Checkmarx tenant'
    required: true
  base-uri:
    description: 'Checkmarx server URL'
    required: false
    default: 'https://eu-2.ast.checkmarx.net/'
  repo-url:
    description: 'Repository URL to scan (defaults to PR head repo)'
    required: false
    default: ${{ github.event.pull_request.head.repo.html_url || format('https://github.com/{0}', github.repository) }}
  branch:
    description: 'Branch to scan (defaults to PR head ref or current branch)'
    required: false
    default: ${{ github.event.pull_request.head.ref || github.ref_name }}
  file-filter:
    description: 'File exclusion patterns (comma-separated glob patterns, e.g. !*.json,!test/*)'
    required: false
    default: ''
  upload-to-github:
    description: 'Upload SARIF to GitHub Security'
    required: false
    default: 'true'
  upload-to-checkmarx:
    description: 'Upload SARIF to Checkmarx via BYOR'
    required: false
    default: 'true'
  scs-repo-token:
    description: 'GitHub token for SCS scanning (defaults to github.token for public repos)'
    required: false
    default: ''

outputs:
  scan-id:
    description: 'Checkmarx scan ID'
    value: ${{ steps.scan.outputs.scan-id }}
  sarif-file:
    description: 'Path to generated SARIF file'
    value: 'cx_result.sarif'

runs:
  using: 'composite'
  steps:
    # NO CHECKOUT - This is critical for security with pull_request_target

    - name: Display scan parameters
      shell: bash
      env:
        INPUT_REPO_URL: ${{ inputs.repo-url }}
        INPUT_BRANCH: ${{ inputs.branch }}
        INPUT_PROJECT_NAME: ${{ inputs.project-name }}
        INPUT_SCS_TOKEN: ${{ inputs.scs-repo-token }}
        GITHUB_TOKEN: ${{ github.token }}
      run: |
        set -euo pipefail
        IFS=$'\n\t'

        echo "=== Checkmarx Fork-Friendly Scan ==="
        echo "Repository: ${INPUT_REPO_URL}"
        echo "Branch: ${INPUT_BRANCH}"
        echo "Project: ${INPUT_PROJECT_NAME}"
        echo "Scan Types: All licensed scanners (SAST, SCA, KICS, API Security, Container Security, etc.)"
        if [ -n "${INPUT_SCS_TOKEN:-}" ] || [ -n "${GITHUB_TOKEN:-}" ]; then
          echo "SCS/Scorecard: Enabled"
        else
          echo "SCS/Scorecard: Disabled (no token available)"
        fi
        echo "Note: No code checkout - Checkmarx will fetch directly"

    - name: Install Checkmarx CLI
      shell: bash
      run: |
        set -euo pipefail
        IFS=$'\n\t'

        CLI_VERSION="2.3.37"
        echo "Installing Checkmarx CLI ${CLI_VERSION}..."

        # Detect OS and architecture
        OS=$(uname -s | tr '[:upper:]' '[:lower:]')
        ARCH=$(uname -m)

        case "$ARCH" in
          x86_64) ARCH="x64" ;;
          aarch64|arm64) ARCH="arm64" ;;
          *) echo "::error::Unsupported architecture: $ARCH"; exit 1 ;;
        esac

        # Download CLI
        CLI_URL="https://github.com/Checkmarx/ast-cli/releases/download/${CLI_VERSION}/ast-cli_${CLI_VERSION}_${OS}_${ARCH}.tar.gz"

        echo "Downloading from: $CLI_URL"
        curl -L -o cx-cli.tar.gz "$CLI_URL"
        tar -xzf cx-cli.tar.gz
        chmod +x cx

        # Verify installation
        ./cx version

    - name: Authenticate with Checkmarx
      shell: bash
      env:
        INPUT_BASE_URI: ${{ inputs.base-uri }}
        INPUT_CLIENT_ID: ${{ inputs.cx-client-id }}
        INPUT_CLIENT_SECRET: ${{ inputs.cx-client-secret }}
        INPUT_TENANT: ${{ inputs.cx-tenant }}
        INPUT_SCS_TOKEN: ${{ inputs.scs-repo-token }}
        GITHUB_TOKEN: ${{ github.token }}
      run: |
        set -euo pipefail
        IFS=$'\n\t'

        echo "Authenticating with Checkmarx..."
        ./cx configure set --prop-name cx_base_uri --prop-value "${INPUT_BASE_URI}"
        ./cx configure set --prop-name cx_client_id --prop-value "${INPUT_CLIENT_ID}"
        ./cx configure set --prop-name cx_client_secret --prop-value "${INPUT_CLIENT_SECRET}"
        ./cx configure set --prop-name cx_tenant --prop-value "${INPUT_TENANT}"

        # Configure SCS token (avoid exposing in CLI args)
        if [ -n "${INPUT_SCS_TOKEN:-}" ]; then
          echo "Configuring SCS token..."
          ./cx configure set --prop-name scs_repo_token --prop-value "${INPUT_SCS_TOKEN}"
        elif [ -n "${GITHUB_TOKEN:-}" ]; then
          echo "Configuring SCS with GitHub token..."
          ./cx configure set --prop-name scs_repo_token --prop-value "${GITHUB_TOKEN}"
        fi

        # Test authentication
        if ./cx auth validate; then
          echo "✅ Authentication successful"
        else
          echo "::error::Failed to authenticate with Checkmarx"
          exit 1
        fi

    - name: Run Checkmarx Scan on Remote Repository
      shell: bash
      id: scan
      env:
        INPUT_PROJECT_NAME: ${{ inputs.project-name }}
        INPUT_REPO_URL: ${{ inputs.repo-url }}
        INPUT_BRANCH: ${{ inputs.branch }}
        INPUT_FILE_FILTER: ${{ inputs.file-filter }}
        INPUT_SCS_TOKEN: ${{ inputs.scs-repo-token }}
        GITHUB_TOKEN: ${{ github.token }}
      run: |
        set -euo pipefail
        IFS=$'\n\t'

        echo "Scanning remote repository..."
        echo "URL: ${INPUT_REPO_URL}"
        echo "Branch: ${INPUT_BRANCH}"

        # Build scan command using array (prevents injection)
        args=(./cx scan create)
        args+=(--project-name "${INPUT_PROJECT_NAME}")
        args+=(-s "${INPUT_REPO_URL}")
        args+=(--branch "${INPUT_BRANCH}")
        args+=(--report-format sarif)
        args+=(--output-path .)

        # Add SCS repo URL if token configured (token already in config)
        if [ -n "${INPUT_SCS_TOKEN:-}" ] || [ -n "${GITHUB_TOKEN:-}" ]; then
          echo "Adding SCS parameters..."
          args+=(--scs-repo-url "${INPUT_REPO_URL}")
        fi

        # Add file filter if provided
        if [ -n "${INPUT_FILE_FILTER:-}" ]; then
          # Validate: only allow safe characters for glob patterns
          if [[ "${INPUT_FILE_FILTER}" =~ ^[a-zA-Z0-9\!\*\.\-\_\/\,]+$ ]]; then
            echo "Adding file filter: ${INPUT_FILE_FILTER}"
            args+=(--file-filter "${INPUT_FILE_FILTER}")
          else
            echo "::error::Invalid file-filter pattern: contains forbidden characters"
            exit 1
          fi
        fi

        # Execute scan safely (no eval)
        echo "Executing scan..."
        if "${args[@]}"; then
          echo "✅ Scan completed successfully"

          # Find the SARIF file
          if [ -f "cx_result.sarif" ]; then
            echo "SARIF file generated: cx_result.sarif"
            echo "scan-id=success" >> "${GITHUB_OUTPUT}"
          else
            echo "::warning::SARIF file not found at expected location"
            # Try to find any SARIF file
            find . -name "*.sarif" -type f | head -1 || true
          fi
        else
          echo "::error::Checkmarx scan failed"
          exit 1
        fi

    - name: Fix SARIF for GitHub compatibility
      if: ${{ hashFiles('cx_result.sarif') != '' }}
      shell: bash
      run: |
        set -euo pipefail
        IFS=$'\n\t'

        # GitHub fails if artifactLocation.uri is empty
        if [ -f "./cx_result.sarif" ]; then
          # jq is pre-installed on GitHub Actions runners
          if command -v jq &> /dev/null; then
            # Fix empty URIs
            mv ./cx_result.sarif ./cx_result.sarif.orig
            jq '.runs |= map(.results |= map(.locations |= map(if .physicalLocation.artifactLocation.uri == "" then .physicalLocation.artifactLocation.uri = "file:/README.md" else . end)))' cx_result.sarif.orig > cx_result.sarif.tmp

            # Fix missing message text
            jq '.runs[].results[] |= (if .message.text == null or .message.text == "" then .message.text = ("Security issue detected by " + .ruleId) else . end)' cx_result.sarif.tmp > cx_result.sarif
            rm -f cx_result.sarif.tmp cx_result.sarif.orig

            echo "✅ Fixed SARIF for GitHub compatibility"
          else
            echo "::warning::jq not available, SARIF may have compatibility issues"
          fi
        fi

    - name: Upload SARIF to GitHub Security
      if: ${{ inputs.upload-to-github == 'true' && hashFiles('cx_result.sarif') != '' }}
      uses: github/codeql-action/upload-sarif@755f44910c12a3d7ca0d8c6e42c048b3362f7cec  # v3.30.8
      with:
        sarif_file: cx_result.sarif
      continue-on-error: true

    - name: Upload SARIF to Checkmarx BYOR
      if: ${{ inputs.upload-to-checkmarx == 'true' && hashFiles('cx_result.sarif') != '' }}
      shell: bash
      env:
        INPUT_PROJECT_NAME: ${{ inputs.project-name }}
      run: |
        set -euo pipefail
        IFS=$'\n\t'

        echo "Uploading SARIF to Checkmarx via BYOR..."
        echo "Project: ${INPUT_PROJECT_NAME}"

        if ./cx utils import --project-name "${INPUT_PROJECT_NAME}" --import-file-path "cx_result.sarif"; then
          echo "✅ SARIF successfully uploaded to Checkmarx"
        else
          echo "::warning::Failed to upload SARIF to Checkmarx BYOR"
        fi
      continue-on-error: true

    - name: Cleanup
      if: always()
      shell: bash
      run: |
        set -euo pipefail
        IFS=$'\n\t'

        # Clear stored credentials
        ./cx configure clear || true

        # Clean up CLI installation files
        rm -f cx-cli.tar.gz cx LICENSE README.md || true

        echo "✅ Cleanup completed"